
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OAS - Telemetry</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #dddddd;
        padding: 8px;
        text-align: left;
        cursor: pointer;
    }
    th {
        background-color: #f2f2f2;
    }
    #telemetryStatusSpan {
        color:rgb(0, 123, 6);
        font-size: x-small;
    }
</style>
</head>
<body>
<h1>Telemetry <span id="telemetryStatusSpan"></span></h1>
<table id="apiTable">
    <thead>
        <tr>
            <th onclick="sortTable(0)">Path</th>
            <th onclick="sortTable(1)">Method</th>
            <th onclick="sortTable(2)">Status</th>
            <th onclick="sortTable(3)">Description</th>
            <th onclick="sortTable(4)" style="text-align: center;">Request <br>Count</th>
            <th onclick="sortTable(5)" style="text-align: center;">Average response time<br> (sec)</th>
            
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>
<br/>
<button onclick="fetch('/telemetry/start');loadTelemetryStatus();">Start</button>
<button onclick="fetch('/telemetry/stop');loadTelemetryStatus();">Stop</button>
<button onclick="fetch('/telemetry/reset');loadTelemetryStatus();">Reset</button>
<script>

async function fetchSpec() {
  try {
    const response = await fetch("/telemetry/spec");
    if (!response.ok) {
      throw new Error("ERROR getting the Spec");
    }
    apiSpec = await response.json();
    loadAPISpec(apiSpec); 
    loadTelemetryStatus();
  } catch (error) {
    console.error("ERROR getting the Spec :", error);
  }
}

async function loadTelemetryStatus(){
    console.log("TEST");
    const tss = document.getElementById("telemetryStatusSpan");
    const response = await fetch("/telemetry/status");
    if (!response.ok) {
      throw new Error("ERROR getting the Status");
      return;
    }
    tStatus = await response.json();

    console.log(tStatus);
    if(tStatus.active){
        tss.textContent = "active";
        tss.style.color = "#009900";
    }
    else{
        tss.textContent = "stoped";
        tss.style.color = "#666666";
    }

}



function getPathRegEx(path){
    let pathComponents = path.split("/");
    let pathRegExpStr = "^"

    pathComponents.forEach(c =>{
        if(c != "") {
            pathRegExpStr += "/";
            if(c.charAt(0) == "{" && c.charAt(c.length-1) == "}"){
                pathRegExpStr += "(.*)";
            }else{
                pathRegExpStr += c;
            }
        }
    });
    
    pathRegExpStr += "$";

    return new RegExp(pathRegExpStr);
}


async function fetchTracesByParsing(path,method,status) {
    try {
        console.log(`Fetchig traces for <${path}> - ${method} - ${status},.. `);

        const response = await fetch("/telemetry/list");

        if (!response.ok) {
        throw new Error("ERROR getting the Traces.");
        }

        const responseJSON = await response.json();
        const traces = responseJSON.spans;

        console.log(`Feched ${traces.length} traces.`);
        //console.log(`First trace: ${JSON.stringify(traces[0],null,2)}`);
        
        return traces.filter((t)=>{
            return (
                (getPathRegEx(path).test(t.attributes.http_dot_target)) &&
                (t.attributes.http_dot_method.toUpperCase().includes(method.toUpperCase())) &&
                (t.attributes.http_dot_status_code == status) 
            );
        });

    } catch (error) {
        console.error("ERROR getting the Traces :", error);
    }
}

function parseTraceInfo(t){
    const ep = t.attributes.http_dot_target;
    const method = t.attributes.http_dot_method.toLowerCase();
    const status = t.attributes.http_dot_status_code;

    const startSec = t.startTime[0];
    const startNanoSec = t.startTime[1];
    const endSec = t.endTime[0];
    const endNanoSec = t.endTime[1];
    
    const durationSec = endSec -startSec;
    let durationNanoSec = endNanoSec -startNanoSec;
    if (durationSec)
        durationNanoSec = endNanoSec;

    const durationMiliSec = Math.round(durationNanoSec / 10000);

    const duration = durationSec + (durationMiliSec / 1000)
                        
    let startDateObj = new Date((startSec * 1000)+(startNanoSec / 10000));
    let startTS = startDateObj.toISOString();
    
    let endDateObj = new Date((endSec * 1000)+(endNanoSec / 10000));
    let endTS = endDateObj.toISOString();
    
    console.log(`${startTS} - ${endTS} - ${t._spanContext.traceId} - ${t.name} - ${ep} - ${status} - ${duration}`);
    return {
        ts : startTS,
        ep: ep,
        method: method,
        status: status,
        duration: duration
    };
}

async function loadStats(path,method,status,cellRequestCount,cellAverageResponseTime){
    let traces = await fetchTracesByParsing(path,method,status);
    let requestCount = traces.length;
    let averageResponseTime = 0;
    
    traces.forEach(trace=>{
        t = parseTraceInfo(trace);
        averageResponseTime += t.duration;
    });
    averageResponseTime = averageResponseTime / requestCount;

    cellRequestCount.textContent = requestCount;
    cellAverageResponseTime.textContent = requestCount? averageResponseTime.toFixed(3):"--";

    setTimeout(loadStats,2000,path,method,status,cellRequestCount,cellAverageResponseTime);
                    
}

function loadAPISpec(apiSpec) {

    const tableBody = document.getElementById('apiTable').getElementsByTagName('tbody')[0];
    Object.keys(apiSpec.paths).forEach(path => {
        Object.keys(apiSpec.paths[path]).forEach(method => {
            Object.keys(apiSpec.paths[path][method].responses).forEach(responseType => {
                if(!Number.isNaN(parseInt(responseType))){
                    const row = tableBody.insertRow();
                    const cellPath = row.insertCell(0);
                    const cellMethod = row.insertCell(1);
                    const cellStatus = row.insertCell(2);
                    const cellDescription = row.insertCell(3);
                    const cellRequestCount = row.insertCell(4);
                    cellRequestCount.style="text-align: center;"
                    const cellAverageResponseTime = row.insertCell(5);
                    cellAverageResponseTime.style.textAlign = "center";
                    
                    cellPath.textContent = path;
                    cellMethod.textContent = method.toUpperCase();
                    cellStatus.textContent = responseType;
                    cellDescription.textContent =   apiSpec.paths[path][method].summary 
                                                + " - " 
                                                + apiSpec.paths[path][method].responses[responseType].description;


                    loadStats(path,method.toLowerCase(),responseType,cellRequestCount,cellAverageResponseTime);
                    setTimeout(loadStats,1000,path,method.toLowerCase(),responseType,cellRequestCount,cellAverageResponseTime);
                    
                    
                    row.detailPath = `/telemetry/detail/${responseType}/${method.toLowerCase()}${path}`;
                    row.onclick = function(){
                        window.location.href = this.detailPath;
                    };
                }
            });
        });
    });
}

function sortTable(column) {
    const table = document.getElementById('apiTable');
    let rows, switching, i, x, y, shouldSwitch;
    switching = true;
    // Loop until no switching has been done:
    while (switching) {
        switching = false;
        rows = table.rows;
        // Loop through all table rows (except the first, which contains table headers):
        for (i = 1; i < (rows.length - 1); i++) {
            shouldSwitch = false;
            // Get the two elements you want to compare, one from current row and one from the next:
            x = rows[i].getElementsByTagName("TD")[column];
            y = rows[i + 1].getElementsByTagName("TD")[column];
            // Check if the two rows should switch place:
            if (x.textContent.toLowerCase() > y.textContent.toLowerCase()) {
                shouldSwitch = true;
                break;
            }
        }
        if (shouldSwitch) {
            // If a switch has been marked, make the switch and mark that a switch has been done:
            rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
            switching = true;
        }
    }
}

window.onload = fetchSpec();
</script>
</body>
</html>